"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolveOptions;

var _utils = require("@parcel/utils");

var _loadDotEnv = _interopRequireDefault(require("./loadDotEnv"));

var _path = _interopRequireDefault(require("path"));

var _fs = require("@parcel/fs");

var _cache = _interopRequireDefault(require("@parcel/cache"));

var _packageManager = require("@parcel/package-manager");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// Default cache directory name
const DEFAULT_CACHE_DIRNAME = '.parcel-cache';
const LOCK_FILE_NAMES = ['yarn.lock', 'package-lock.json', 'pnpm-lock.yaml'];

async function resolveOptions(initialOptions) {
  var _initialOptions$mode, _initialOptions$minif, _initialOptions$patch, _initialOptions$env, _initialOptions$autoi, _initialOptions$hot, _initialOptions$serve, _initialOptions$disab, _initialOptions$killW, _initialOptions$profi, _initialOptions$sourc, _initialOptions$scope, _initialOptions$logLe;

  let entries;

  if (initialOptions.entries == null || initialOptions.entries === '') {
    entries = [];
  } else if (Array.isArray(initialOptions.entries)) {
    entries = initialOptions.entries.map(entry => _path.default.resolve(entry));
  } else {
    entries = [_path.default.resolve(initialOptions.entries)];
  }

  let inputFS = initialOptions.inputFS || new _fs.NodeFS();
  let outputFS = initialOptions.outputFS || new _fs.NodeFS();
  let packageManager = initialOptions.packageManager || new _packageManager.NodePackageManager(inputFS);
  let rootDir = initialOptions.rootDir != null ? _path.default.resolve(initialOptions.rootDir) : (0, _utils.getRootDir)(entries);

  let projectRootFile = (await (0, _utils.resolveConfig)(inputFS, _path.default.join(rootDir, 'index'), [...LOCK_FILE_NAMES, '.git', '.hg'])) || _path.default.join(inputFS.cwd(), 'index'); // ? Should this just be rootDir


  let lockFile = null;

  let rootFileName = _path.default.basename(projectRootFile);

  if (LOCK_FILE_NAMES.includes(rootFileName)) {
    lockFile = projectRootFile;
  }

  let projectRoot = _path.default.dirname(projectRootFile);

  let outputCwd = outputFS.cwd();
  let cacheDir = // If a cacheDir is provided, resolve it relative to cwd. Otherwise,
  // use a default directory resolved relative to the project root.
  initialOptions.cacheDir != null ? _path.default.resolve(outputCwd, initialOptions.cacheDir) : _path.default.resolve(projectRoot, DEFAULT_CACHE_DIRNAME);
  let cache = new _cache.default(outputFS, cacheDir);
  let mode = (_initialOptions$mode = initialOptions.mode) !== null && _initialOptions$mode !== void 0 ? _initialOptions$mode : 'development';
  let minify = (_initialOptions$minif = initialOptions.minify) !== null && _initialOptions$minif !== void 0 ? _initialOptions$minif : mode === 'production';
  return {
    config: initialOptions.config,
    defaultConfig: initialOptions.defaultConfig,
    patchConsole: (_initialOptions$patch = initialOptions.patchConsole) !== null && _initialOptions$patch !== void 0 ? _initialOptions$patch : process.env.NODE_ENV !== 'test',
    env: _objectSpread({}, initialOptions.env, {}, (await (0, _loadDotEnv.default)((_initialOptions$env = initialOptions.env) !== null && _initialOptions$env !== void 0 ? _initialOptions$env : {}, inputFS, _path.default.join(projectRoot, 'index')))),
    mode,
    minify,
    autoinstall: (_initialOptions$autoi = initialOptions.autoinstall) !== null && _initialOptions$autoi !== void 0 ? _initialOptions$autoi : true,
    hot: (_initialOptions$hot = initialOptions.hot) !== null && _initialOptions$hot !== void 0 ? _initialOptions$hot : false,
    serve: (_initialOptions$serve = initialOptions.serve) !== null && _initialOptions$serve !== void 0 ? _initialOptions$serve : false,
    disableCache: (_initialOptions$disab = initialOptions.disableCache) !== null && _initialOptions$disab !== void 0 ? _initialOptions$disab : false,
    killWorkers: (_initialOptions$killW = initialOptions.killWorkers) !== null && _initialOptions$killW !== void 0 ? _initialOptions$killW : true,
    profile: (_initialOptions$profi = initialOptions.profile) !== null && _initialOptions$profi !== void 0 ? _initialOptions$profi : false,
    cacheDir,
    entries,
    rootDir,
    defaultEngines: initialOptions.defaultEngines,
    targets: initialOptions.targets,
    sourceMaps: (_initialOptions$sourc = initialOptions.sourceMaps) !== null && _initialOptions$sourc !== void 0 ? _initialOptions$sourc : true,
    scopeHoist: (_initialOptions$scope = initialOptions.scopeHoist) !== null && _initialOptions$scope !== void 0 ? _initialOptions$scope : initialOptions.mode === 'production',
    logLevel: (_initialOptions$logLe = initialOptions.logLevel) !== null && _initialOptions$logLe !== void 0 ? _initialOptions$logLe : 'info',
    projectRoot,
    lockFile,
    inputFS,
    outputFS,
    cache,
    packageManager
  };
}