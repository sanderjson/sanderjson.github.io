"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _assert = _interopRequireDefault(require("assert"));

var _plugin = require("@parcel/plugin");

var _utils = require("@parcel/utils");

var _path = _interopRequireDefault(require("path"));

var _nullthrows = _interopRequireDefault(require("nullthrows"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _default = new _plugin.Reporter({
  async report({
    event,
    options
  }) {
    if (event.type !== 'buildSuccess' || process.env.PARCEL_BUNDLE_ANALYZER == null) {
      return;
    }

    let bundlesByTarget = new _utils.DefaultMap(() => []);

    for (let bundle of event.bundleGraph.getBundles()) {
      bundlesByTarget.get(bundle.target.name).push(bundle);
    }

    let reportsDir = _path.default.join(options.projectRoot, 'parcel-bundle-reports');

    await options.outputFS.mkdirp(reportsDir);
    await Promise.all([...bundlesByTarget.entries()].map(async ([targetName, bundles]) => {
      return options.outputFS.writeFile(_path.default.join(reportsDir, `${targetName}.html`), `
          <html>
            <head>
              <meta charset="utf-8">
              <title>ðŸ“¦Parcel Bundle Analyzer | ${targetName}</title>
              <style>
                body {
                  margin: 0;
                }

                .tooltip {
                  background-color: rgba(255, 255, 255, 0.7);
                  left: 0;
                  padding: 20px;
                  pointer-events: none;
                  position: absolute;
                  top: 0;
                  transform: translate3d(0, 0, 0);
                }

                .tooltip-content {
                  font-family: monospace;
                }

                .tooltip-content dl div {
                  display: flex;
                }

                .tooltip-title {
                  font-size: 18px;
                }
              </style>
              <script>
                ${await options.inputFS.readFile(_path.default.resolve(__dirname, '../client/vendor/foamtree/carrotsearch.foamtree.js'), 'utf8')}
              </script>
              <script id="bundle-data" type="application/json">
                ${JSON.stringify(getBundleData(bundles, options))}
              </script>
            </head>
            <body>
              <script>
                ${await options.inputFS.readFile(_path.default.resolve(__dirname, '../client/index.js'), 'utf8')}
              </script>
            </body>
          </html>
        `);
    }));
  }

});

exports.default = _default;

function getBundleData(bundles, options) {
  return {
    groups: bundles.map(bundle => getBundleNode(bundle, options))
  };
}

let createMap = () => new _utils.DefaultMap(() => createMap());

function getBundleNode(bundle, options) {
  let assets = [];
  bundle.traverseAssets(asset => {
    assets.push(asset);
  });
  let dirMap = createMap();

  for (let asset of assets) {
    let relativePath = _path.default.relative(options.projectRoot, asset.filePath);

    let parts = relativePath.split(_path.default.sep);
    let dirs = parts.slice(0, parts.length - 1);
    let basename = parts[parts.length - 1];
    let map = dirMap;

    for (let dir of dirs) {
      (0, _assert.default)(map instanceof _utils.DefaultMap);
      map = map.get(dir);
    }

    (0, _assert.default)(map instanceof _utils.DefaultMap);
    map.set(basename, {
      basename: _path.default.basename(asset.filePath),
      stats: asset.stats
    });
  }

  return {
    label: (0, _nullthrows.default)(bundle.name),
    weight: bundle.stats.size,
    groups: generateGroups(dirMap)
  };
}

function generateGroups(dirMap) {
  let groups = [];

  for (let [directoryName, contents] of dirMap) {
    if (contents instanceof _utils.DefaultMap) {
      let childrenGroups = generateGroups(contents);

      if (childrenGroups.length === 1) {
        let firstChild = childrenGroups[0];
        groups.push(_objectSpread({}, firstChild, {
          label: _path.default.join(directoryName, firstChild.label)
        }));
      } else {
        groups.push({
          label: directoryName,
          weight: childrenGroups.reduce((acc, g) => acc + (0, _nullthrows.default)(g.weight), 0),
          groups: childrenGroups
        });
      }
    } else {
      // file
      groups.push({
        label: contents.basename,
        weight: contents.stats.size
      });
    }
  }

  return groups;
}